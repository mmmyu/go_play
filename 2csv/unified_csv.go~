package main

import (
	"encoding/csv"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"
)

func parseArgs(args []string) (string, string) {
	if len(args) != 3 {
		fmt.Fprintf(os.Stderr, "Usage: %s <file_type> <input>.\n", args[0])
		fmt.Fprintf(os.Stderr, "  file_type: wfb|amex|cap1|chase|citi.\n")
		return "", ""
	}
	return args[1], args[2]
}

const (
	out_date   = iota
	out_amount = iota
	out_desc   = iota
)

func convertDate(d string) string {
	t, err := time.Parse("1/2/2006", d)
	if err != nil {
		return ""
	}
	return t.Format("2006-01-02")
}

func convertWFB(record []string) []string {
	out := make([]string, 7)
	amt, err := strconv.ParseFloat(record[1], 32)
	if err != nil {
		panic(err)
	}
	if amt >= 0.0 || strings.HasPrefix(record[4], "BILL PAY") || strings.Contains(record[4], " INVESTMENT") ||
		strings.Contains(record[4], " ONLINE TRANSFER") {
		return out
	}
	out[out_date] = convertDate(record[0])
	out[out_desc] = record[3] + " " + record[4]
	out[5] = strconv.FormatFloat(-amt, 'f', -1, 32)
	out[6] = strconv.FormatFloat(amt, 'f', -1, 32)
	return out
}

func convertAmex(record []string) []string {
	out := make([]string, 3)
	out[out_date] = convertDate(record[0])
	out[out_amount] = record[2]
	out[out_desc] = record[3] + " " + record[4]
	return out
}

func convertCap1(record []string) []string {
	out := make([]string, 3)
	out[out_date] = convertDate(record[0])
	if out[out_date] == "" {
		return out
	}
	debit, err := strconv.ParseFloat(record[3], 32)
	if err != nil {
		debit = 0
	}
	credit, err := strconv.ParseFloat(record[4], 32)
	if err != nil {
		credit = 0
	}
	amt := credit - debit
	out[out_amount] = strconv.FormatFloat(amt, 'f', -1, 32)
	out[out_desc] = record[2]
	return out
}

func convertCiti(record []string) []string {
	out := make([]string, 3)
	out[out_date] = convertDate(record[0])
	amt, err := strconv.ParseFloat(record[1][1:], 32)
	if err != nil {
		panic(err)
	}
	out[out_amount] = strconv.FormatFloat(-amt, 'f', -1, 32)
	out[out_desc] = record[2]
	return out
}

func convertChase(record []string) []string {
	out := make([]string, 3)
	out[out_date] = convertDate(record[1])
	if out[out_date] == "" {
		return out
	}
	out[out_amount] = record[4]
	out[out_desc] = record[3]
	return out
}

func convert(ftype, fname string) {
	fi, err := os.Open(fname)
	if err != nil {
		panic(err)
	}
	defer fi.Close()
	reader := csv.NewReader(fi)
	switch ftype {
	case "citi":
		reader.Comma = '\t'
	}
	writer := csv.NewWriter(os.Stdout)
	defer writer.Flush()
	for {
		record, err := reader.Read()
		if err != nil {
			break
		}
		var out []string
		switch ftype {
		case "wfb":
			out = convertWFB(record)
		case "amex":
			out = convertAmex(record)
		case "cap1":
			out = convertCap1(record)
		case "citi":
			out = convertCiti(record)
		case "chase":
			out = convertChase(record)
		default:
			panic("Unknown file type " + ftype)
		}
		if out[out_date] != "" {
			writer.Write(out)
		}
	}
}

// Parses banks checking activity csv file
func main() {
	ftype, fname := parseArgs(os.Args)
	if ftype == "" || fname == "" {
		return
	}
	convert(ftype, fname)
}
